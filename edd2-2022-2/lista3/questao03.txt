A forma de uma árvore a torna ideal para o uso de recursividade, já que a mesma função pode ser utilizada em qualquer nó da árvore para procurar qualquer elemento abaixo de um nó específico. Ou seja, a recursão oferece simplicidade, porém pode trazer algumas desvantagens, já que alguns algoritmos requerem grandes espaços de memória se a profundidade da recursão for muito grande. O grande consumo de memória pode ser causado pelo grande número de chamadas de função pela recursividade. Cada chamada de função resulta em consumo de memória da stack do thread. É importante complementar que caso uma BST não esteja balanceada, isso pode causar aumento na complexidade, já que os custos de operações podem deixar de ser logarítmicos e se transformarem em uma busca linear (O(n)) em um vetor. Ou seja, no pior dos casos, quando uma árvore é degenerada, a busca irá percorrer todos os nós de um lado, apenas para depois desempilhar os valores na pilha de recursão e retornar nulo quando chegar na raiz, caso não encontre o valor. Isso aumenta a complexidade e, consequentemente, o seu tempo de execução. Mas, se fosse uma busca iterativa, por exemplo, que também possui loops mas que não utilizam recursão, e sim repetição, rendendo complexidade e tempo de execução menores.